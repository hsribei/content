<h1 id="full-feature-integration">Build scalable dataviz components with full integration</h1>
<p>As useful as blackbox components are, we need something better if we want to leverage Reactâ€™s rendering engine. The blackbox approach in particular struggles with scale. The more charts and graphs and visualizations on your screen, the slower it gets.</p>
<p>Someone once came to my workshop and said <em>â€œWe used the blackbox approach and it takes several seconds to re-render our dashboard on any change. Iâ€™m here to learn how to do it better.â€</em></p>
<p>In our full-feature integration, React does the rendering and D3 calculates the props.</p>
<p>Our goal is to build controlled components that listen to their props and reconcile that with D3â€™s desire to use a lot of internal state.</p>
<p>There are two situations we can find ourselves in:</p>
<ol type="1">
<li>We know for a fact our componentâ€™s props never change</li>
<li>We think props could change</li>
</ol>
<p>Itâ€™s easiest to show you with an example.</p>
<p>Letâ€™s build a scatterplot step by step. Take a random array of two-dimensional data, render in a loop. Make magic.</p>
<p>Something like this ğŸ‘‡</p>
<figure>
<img src="https://raw.githubusercontent.com/Swizec/react-d3js-es6-ebook/2018-version/manuscript/resources/images/2018/scatterplot.png" alt="A simple scatterplot"><figcaption>A simple scatterplot</figcaption>
</figure>
<p>Youâ€™ve already built the axes! Copy pasta time.</p>