<h1 id="speed-optimizations">Speed optimizations</h1>
<p>Welcome to the speed optimization chapter. This is where we make our code harder to read and faster to run.</p>
<p>You might never need any techniques discussed here.</p>
<p>You already know how to build performant data visualization components. For 99% of applications, plain code thatâ€™s easy to read and understand is faster than fast code thatâ€™s hard to read.</p>
<p>You and your team spend most of your time reading code. Optimize for that. The faster you can code, the faster your system can evolve. Leave runtime optimization to React and its ecosystem of library authors for as long as you can get away with.</p>
<p>Do you really need to save that tenth of a second at runtime if it means an extra hour of head scratching every time thereâ€™s a bug?</p>
<p>Be honest. <span class="emoji" data-emoji="wink">ðŸ˜‰</span></p>
<p>That said, there <em>are</em> cases where faster code is also easier to read. And there are cases where your visualization is so massive, that you need every ounce of oomph you can get.</p>
<p>For the most part, weâ€™re going to talk about three things:</p>
<ul>
<li>using Canvas to speed up rendering</li>
<li>using React-like libraries to speed up the core rendering engine</li>
<li>avoiding unnecessary computation and redraws</li>
<li>reaching for WebGL when even Canvas isnâ€™t fast enough</li>
</ul>
<p>Weâ€™ll start with Canvas because itâ€™s the best bang for buck improvement you can make.</p>