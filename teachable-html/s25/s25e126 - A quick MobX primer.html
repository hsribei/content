<h3 id="a-quick-mobx-primer">A quick MobX primer</h3>
<p>Explaining MobX in detail is beyond the scope of this book. You can learn it by osmosis as you follow the code in our billiards example.</p>
<p>That said, here’s a quick rundown of the concepts we’re using.</p>
<p>MobX is based on reactive programming. There are values that are observable and functions that react when those values change. MobX ensures only the minimal possible set of observers is triggered on every change.</p>
<p>So, we have:</p>
<p><code>@observable</code> – a property whose changes observers subscribe to <code>@observer</code> – a component whose <code>render()</code> method observes values <code>@computed</code> – a method whose value can be fully derived from observables <code>@action</code> – a method that changes state, analogous to a Redux reducer <code>@inject</code> – a decorator that injects global stores into a component’s props</p>
<p>That’s all you need to know. Once your component is an <code>@observer</code>, you never have to worry about <em>what</em> it’s observing. MobX ensures it reacts to changes in values used during rendering.</p>
<p>Making your component an observer and injecting the global store is the same as using <code>connect</code> in Redux. It gives your component access to your state, and it triggers a re-render when something changes.</p>
<p>Importantly, it <em>doesn’t</em> trigger a re-render when something that the component isn’t using changes. That little tidbit is what makes many other reactive libraries difficult to use.</p>